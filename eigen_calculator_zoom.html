<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>特征值/特征向量计算与可视化工具 V13</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 1000px; margin: 20px auto; padding: 0 20px; }
        header, .section-header { text-align: center; }
        h1, h2, h3 { color: #0056b3; }
        .input-container { padding: 20px; background-color: #e9ecef; border-radius: 8px; margin-bottom: 20px; text-align: center; }
        .matrix-input { display: inline-block; vertical-align: middle; }
        .matrix-input table { border-collapse: collapse; }
        .matrix-input td { padding: 5px; }
        .matrix-input input { width: 50px; text-align: center; font-size: 18px; }
        .brackets { font-size: 80px; font-weight: bold; vertical-align: middle; }
        button { font-size: 18px; padding: 12px 25px; cursor: pointer; display: block; margin: 20px auto; }
        .output-container { display: none; }
        .calculation-log { padding: 15px; background-color: #f8f9fa; border-radius: 8px; margin-bottom: 20px; font-family: 'Courier New', Courier, monospace; }
        .comparison-container { display: flex; justify-content: space-around; align-items: flex-start; gap: 20px; margin-top: 20px; padding-top: 20px; border-top: 2px solid #ccc; }
        .panel { width: 48%; }
        .panel h3 { text-align: center; font-size: 1em; }
        svg { border: 1px solid #ccc; width: 100%; height: auto; }
        p { text-align: center; }
    </style>
</head>
<body>
    <header><h1>特征值/特征向量计算与可视化工具 (V13)</h1></header>

    <div class="input-container">
        <h3>输入一个 2x2 矩阵 A</h3>
        <span class="brackets">[</span>
        <div class="matrix-input">
            <table>
                <tr>
                    <td><input type="number" id="a" value="2"></td>
                    <td><input type="number" id="b" value="2"></td>
                </tr>
                <tr>
                    <td><input type="number" id="c" value="1"></td>
                    <td><input type="number" id="d" value="3"></td>
                </tr>
            </table>
        </div>
        <span class="brackets">]</span>
    </div>

    <button id="startBtn" onclick="calculateAndVisualize()">计算并可视化</button>

    <div id="outputContainer" class="output-container">
        <div id="calcLog" class="calculation-log"></div>
        <div id="vizContainer"></div>
    </div>

    <script>
        const SVG_NS = "http://www.w3.org/2000/svg";

        function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }

        function simplifyVector(v) {
            if (Math.abs(v.x) < 1e-9 && Math.abs(v.y) < 1e-9) return v;
            const common_divisor = gcd(Math.round(Math.abs(v.x)*100), Math.round(Math.abs(v.y)*100))/100;
            if (common_divisor > 1e-9) {
                v.x /= common_divisor;
                v.y /= common_divisor;
            }
            if (v.x < -1e-9 || (Math.abs(v.x) < 1e-9 && v.y < -1e-9)) {
                v.x *= -1;
                v.y *= -1;
            }
            return v;
        }

        function createVector(x1,y1,x2,y2,c,w=2,s="solid",sc){const l=document.createElementNS(SVG_NS,'line');l.setAttribute('x1',x1*sc);l.setAttribute('y1',-y1*sc);l.setAttribute('x2',x2*sc);l.setAttribute('y2',-y2*sc);l.setAttribute('stroke',c);l.setAttribute('stroke-width',w);l.setAttribute('marker-end',`url(#arrow-${c})`);if(s==='dashed'){l.setAttribute('stroke-dasharray','5,5');}return l;}
        function createMarker(id,c){const m=document.createElementNS(SVG_NS,'marker');m.setAttribute('id',id);m.setAttribute('viewBox','0 0 10 10');m.setAttribute('refX',8);m.setAttribute('refY',5);m.setAttribute('markerWidth',4);m.setAttribute('markerHeight',4);m.setAttribute('orient','auto-start-reverse');const p=document.createElementNS(SVG_NS,'path');p.setAttribute('d','M 0 0 L 10 5 L 0 10 z');p.setAttribute('fill',c);m.appendChild(p);return m;}
        function drawGrid(iv,jv,sc){const g=document.createElementNS(SVG_NS,'g');g.setAttribute('stroke','#ddd');g.setAttribute('stroke-width',0.5);for(let i=-20;i<=20;i++){const sx1=i*iv.x*sc-20*jv.x*sc,sy1=-i*iv.y*sc+20*jv.y*sc,ex1=i*iv.x*sc+20*jv.x*sc,ey1=-i*iv.y*sc-20*jv.y*sc;const l1=document.createElementNS(SVG_NS,'line');l1.setAttribute('x1',sx1);l1.setAttribute('y1',sy1);l1.setAttribute('x2',ex1);l1.setAttribute('y2',ey1);g.appendChild(l1);const sx2=i*jv.x*sc-20*iv.x*sc,sy2=-i*jv.y*sc+20*iv.y*sc,ex2=i*jv.x*sc+20*iv.x*sc,ey2=-i*jv.y*sc-20*iv.y*sc;const l2=document.createElementNS(SVG_NS,'line');l2.setAttribute('x1',sx2);l2.setAttribute('y1',sy2);l2.setAttribute('x2',ex2);l2.setAttribute('y2',ey2);g.appendChild(l2);}return g;}

        function drawScene(svg, i_vec, j_vec, main_vec, scale) {
            svg.innerHTML = '';
            const defs = document.createElementNS(SVG_NS, 'defs');
            defs.appendChild(createMarker(`arrow-${main_vec.color}`, main_vec.color));
            defs.appendChild(createMarker('arrow-red', 'red'));
            defs.appendChild(createMarker('arrow-green', 'green'));
            svg.appendChild(defs);
            svg.appendChild(drawGrid(i_vec, j_vec, scale));
            svg.appendChild(createVector(0,0,i_vec.x, i_vec.y, 'red', 3, 'solid', scale));
            svg.appendChild(createVector(0,0,j_vec.x, j_vec.y, 'green', 3, 'solid', scale));
            const transformed_x = main_vec.x * i_vec.x + main_vec.y * j_vec.x;
            const transformed_y = main_vec.x * i_vec.y + main_vec.y * j_vec.y;
            svg.appendChild(createVector(0,0, transformed_x, transformed_y, main_vec.color, 5, 'solid', scale));
        }
        
        function animate(svg, info, i_start, j_start, i_end, j_end, main_vec, final_vec, scale, duration = 2000) {
            let start_time = null;
            function animation_step(timestamp) {
                if (!start_time) start_time = timestamp;
                const progress = Math.min((timestamp - start_time) / duration, 1);
                const current_i = { x: i_start.x + (i_end.x - i_start.x) * progress, y: i_start.y + (i_end.y - i_start.y) * progress };
                const current_j = { x: j_start.x + (j_end.x - j_start.x) * progress, y: j_start.y + (j_end.y - j_start.y) * progress };
                drawScene(svg, current_i, current_j, main_vec, scale);
                if (progress < 1) { requestAnimationFrame(animation_step); }
                else { info.textContent = `变换后向量: [${final_vec.x.toFixed(2)}, ${final_vec.y.toFixed(2)}]`; }
            }
            requestAnimationFrame(animation_step);
        }

        function animateScalar(svg, info, vec, start_scalar, end_scalar, scale, duration = 2000) {
            let start_time = null;
            function animation_step(timestamp) {
                if (!start_time) start_time = timestamp;
                const progress = Math.min((timestamp - start_time) / duration, 1);
                const current_scalar = start_scalar + (end_scalar - start_scalar) * progress;
                const scaled_vec = { x: vec.x * current_scalar, y: vec.y * current_scalar, color: vec.color};
                drawScene(svg, {x:1, y:0}, {x:0, y:1}, scaled_vec, scale);
                if (progress < 1) { requestAnimationFrame(animation_step); }
                else { info.textContent = `变换后向量: [${scaled_vec.x.toFixed(2)}, ${scaled_vec.y.toFixed(2)}]`; }
            }
            requestAnimationFrame(animation_step);
        }
        
        function calculateAndVisualize() {
            const a = parseFloat(document.getElementById('a').value); const b = parseFloat(document.getElementById('b').value);
            const c = parseFloat(document.getElementById('c').value); const d = parseFloat(document.getElementById('d').value);
            
            if ([a,b,c,d].some(isNaN)) { alert("请输入有效的数字！"); return; }
            
            const A = {i_final: {x: a, y: c}, j_final: {x: b, y: d}};
            const calcLog = document.getElementById('calcLog');
            const vizContainer = document.getElementById('vizContainer');
            const outputContainer = document.getElementById('outputContainer');
            
            calcLog.innerHTML = '';
            vizContainer.innerHTML = '';
            outputContainer.style.display = 'block';

            const trace = a + d;
            const det = a * d - b * c;
            const discriminant = trace * trace - 4 * det;

            let logHTML = '<h3>代数计算过程:</h3>';
            logHTML += `<p>特征方程: &lambda;² - (${trace.toFixed(2)})&lambda; + (${det.toFixed(2)}) = 0</p>`;
            
            if (discriminant < -1e-9) {
                logHTML += "<p><b>结果:</b> 判别式小于0，没有实数特征值。</p>";
                calcLog.innerHTML = logHTML;
                return;
            }

            const lambda1 = (trace + Math.sqrt(discriminant)) / 2;
            const lambda2 = (trace - Math.sqrt(discriminant)) / 2;
            logHTML += `<p><b>解出特征值:</b> &lambda;₁ = ${lambda1.toFixed(2)}, &lambda;₂ = ${lambda2.toFixed(2)}</p>`;
            
            let v1_raw = { x: -b, y: a - lambda1 };
            if (Math.abs(v1_raw.x) < 1e-9 && Math.abs(v1_raw.y) < 1e-9) { v1_raw = { x: d - lambda1, y: -c }; }
            const v1_simple = simplifyVector({...v1_raw});

            let v2_raw = { x: -b, y: a - lambda2 };
            if (Math.abs(v2_raw.x) < 1e-9 && Math.abs(v2_raw.y) < 1e-9) { v2_raw = { x: d - lambda2, y: -c }; }
            const v2_simple = simplifyVector({...v2_raw});

            logHTML += `<p><b>最简特征向量:</b> &lambda;₁ &rarr; v₁=[${v1_simple.x.toFixed(2)}, ${v1_simple.y.toFixed(2)}], &lambda;₂ &rarr; v₂=[${v2_simple.x.toFixed(2)}, ${v2_simple.y.toFixed(2)}]</p>`;
            calcLog.innerHTML = logHTML;

            const eigen_pairs = [
                {lambda: lambda1, vector: { ...v1_simple, color: 'blue'}},
                {lambda: lambda2, vector: { ...v2_simple, color: 'orange'}}
            ];

            eigen_pairs.forEach((pair, index) => {
                if (Math.abs(pair.vector.x) < 1e-6 && Math.abs(pair.vector.y) < 1e-6) return;

                const section = document.createElement('div');
                section.className = 'section-header';
                section.innerHTML = `<h2>情况${index+1}: 特征值 &lambda; = ${pair.lambda.toFixed(2)}</h2><p>对应特征向量 &vec;v = [${pair.vector.x.toFixed(2)}, ${pair.vector.y.toFixed(2)}]</p>`;

                const container = document.createElement('div');
                container.className = 'comparison-container';
                container.innerHTML = `
                    <div class="panel"><h3>左: 矩阵变换 A&vec;v</h3><svg id="canvas${index}-left"></svg><p id="info${index}-left">?</p></div>
                    <div class="panel"><h3>右: 标量乘法 &lambda;&vec;v</h3><svg id="canvas${index}-right"></svg><p id="info${index}-right">?</p></div>`;
                vizContainer.appendChild(section);
                vizContainer.appendChild(container);

                const svgL = document.getElementById(`canvas${index}-left`);
                const infoL = document.getElementById(`info${index}-left`);
                const svgR = document.getElementById(`canvas${index}-right`);
                const infoR = document.getElementById(`info${index}-right`);
                
                const v_final_A = { x: a * pair.vector.x + b * pair.vector.y, y: c * pair.vector.x + d * pair.vector.y };
                
                // NEW: DYNAMIC SCALING CALCULATION
                const max_coord = Math.max(Math.abs(pair.vector.x), Math.abs(pair.vector.y), Math.abs(v_final_A.x), Math.abs(v_final_A.y), 1);
                const view_range = (max_coord + 1) * 2;
                const scale = (svgL.clientWidth || 400) / view_range;
                
                svgL.setAttribute('viewBox', `${-view_range/2*scale} ${-view_range/2*scale} ${view_range*scale} ${view_range*scale}`);
                svgR.setAttribute('viewBox', `${-view_range/2*scale} ${-view_range/2*scale} ${view_range*scale} ${view_range*scale}`);

                drawScene(svgL, {x:1, y:0}, {x:0, y:1}, pair.vector, scale);
                drawScene(svgR, {x:1, y:0}, {x:0, y:1}, pair.vector, scale);
                
                animate(svgL, infoL, {x:1, y:0}, {x:0, y:1}, A.i_final, A.j_final, pair.vector, v_final_A, scale);
                animateScalar(svgR, infoR, pair.vector, 1, pair.lambda, scale);
            });
        }
    </script>
</body>
</html>